# 포인터와 함수에 대한 이해

## 함수의 인자로 배열 전달하기

### 인자전달의 기본방식은 값의 복사이다!
함수호출 시 전달되는 인자의 값은 매개변수에 **복사**가 된다.
- 배열을 통째로 넘겨받으려면 매개변수로 배열을 선언할 수 있어야 한다. 하지만 허용되지 않는다.

### 배열을 함수의 인자로 전달하는 방식
매개변수를 포인터로 주면 배열에 접근이 가능하게 된다.

### 배열을 함수의 인자로 전달받는 함수의 또 다른 선언
```c
void Function(int * param, int len) { ... };
void Function(int param[], int len) { ... };
```

</br>

## Call-by-value vs. Call-by-reference

### 값을 전달하는 형태의 함수호출: Call-by-value
함수를 호출할 때 단순히 값을 전달하는 형태의 함수 호출
- 매개변수는 복사가 되어 사용되는 것이므로 외부 변수의 값을 바꿀 수 없음

### 주소 값을 전달하는 형태의 함수호출: Call-by-reference
함수를 호출할 때 메모리의 접근에 사용되는 주소 값을 전달하는 형태의 함수호출
- 주소 값을 통해 외부 변수의 값을 바꿀 수 있음

### 이제는 scanf 함수호출 시 & 연산자를 붙이는 이유를 알 수 있다.
```scanf``` 함수의 호출도 Call-by-reference 형태의 함수호출에 해당한다.
- 문자열이 저장될 배열의 이름 str의 앞에는 & 연산자를 붙이지 않는다.
    - str은 그 자체로 배열의 주소 값이다.

</br>

## 포인터 대상의 const 선언

### 포인터 변수가 참조하는 대상의 변경을 허용하지 않는 const 선언
```const int *ptr = &num```
- 맨 앞부분에 선언이 되면, 포인터 변수 ptr을 이용해서 ptr이 가리키는 변수에 저장된 값을 변경하는 것을 허용하지 않는다.
- 값을 변경하는 방법에 제한을 두는 것이지 무엇인가를 상수로 맏느는 선언이 아니다.

### 포인터 변수의 상수화
```int * const ptr = &num```
- 포인터 변수 ptr은 상수가 된다.
    - 한번 주소 값이 저장되면  그 값의 변경이 불가능하다는 뜻이며, 한번 가리키기 시작한 변수를 끝까지 가리켜야 한다는 뜻이다.
    - 가리키는 대상에 저장된 값을 변경하는 연산은 문제가 되지 않는다.

### const 선언이 갖는 의미
const 선언을 많이 하면 그만큼 프로그램 코드의 안전성은 높아진다.
- const 선언이 사소하다고 생각이 들 수 있지만, 좋은 프로그래밍 습관은 사소한 것들이 모여서 완성되는 것이다.