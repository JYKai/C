# 상수와 기본 자료형

## C언어가 제공하는 기본 자료형의 이해
자료형은 데이터를 표현하는 기준이다. 때문에 변수도 상수도 자료형에 근거한다.

### 기본 자료형의 종류와 데이터의 표현 범위
**정수형**  
- char, 1바이트, -128 ~ 127
- short, 2바이트, -32,768 ~ 32,767
- int, 4바이트, -2,147,483,648 ~ 2,147,483,647
- long, 4바이트, -2,147,483,648 ~ 2,147,483,647
- long long, 8바이트, -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807

**실수형**  
- float, 4바이트
- double, 8바이트
- long double, 8바이트 이상

### 연산자 sizeof를 이용하면 자료형의 크기를 확인할 수 있다.
```sizeof``` 연산자는 메모리 공간에서 소모하는 메모리의 크기를 바이트 단위로 계산해서 반환한다.
- 변수, 상수 뿐만 아니라 자료형의 이름 또한 올릴 수 있다.
- ```sizeof```는 함수가 아닌 연산자다.

### 정수를 표현 및 처리하기 위한 일반적인 자료형의 선택
일반적으로 CPU가 처리하기에 가장 적합한 크기의 정수 자료형을 int로 정의한다. 따라서 int형 연산의 속도가 다른 자료형의 연산속도에 비해 동일하거나 빠르다.

### 실수를 표현 및 처리하기 위한 일반적인 자료형의 선택
실수 자료형의 선택에 있어서 가장 중요한 요소는 '정밀도' 이다.
- 정밀도 : 오차가 발생하지 않는 소수점 이하의 자릿수
    - float, 4바이트, 정밀도 - 6자리
    - double, 8바이트, 정밀도 - 15자리
    - long double, 12바이트, 정밀도 - 18자리
- 정수 자료형이 int를 보편적으로 선택하듯이, 실수 자료형에서는 double을 보편적으로 사용한다.

### unsigned를 붙여서 0과 양의 정수만 표현하게 할 수 있다.
정수 자료형의 이름에 한해서 unsigned 선언을 추가하면, 0 이상의 값만 표현하는 자료형이 되어서 표현할 수 있는 값의 범위가 양의 정수 방향으로 두 배 더 넓어지게된다.
- MSB 조차 값의 크기를 나타내는 비트로 사용하게 된다.

</br>

## 문자의 표현방식과 문자를 위한 자료형

### 문자의 표현을 위한 약속! 아스키(ASCII) 코드!
아스키 코드는 알파벳과 일부 특수문자를 포함하여 총 128개의 문자로 이뤄져 있다.

### 문자는 이렇게 표현되는 거구나!
```c
int main(void)
{
    char ch1 = 'A';
    char ch2 = 'C';
}
```
- 프로그램상에서의 문자표현에는 작은 따옴표가 사용된다.
- %c : 문자의 형태로 데이터를 출력(또는 입력)하라.
    - 정수가 입력된 경우 아스키 코드 값으로 해석해서 아스키 코드 문자로 출력한다.
- 문자를 저장하는 데에는 int형 변수보다 char형 변수가 더 적합하다.

</br>

## 상수에 대한 이해
변수의 상대적인 개념이며, 상수는 크게 이름이 있는 상수와 이름이 없는 상수로 나뉘고, int, double과 같은 자료형을 근거로 표현이 된다.

### 이름을 지니지 않는 리터럴(Literal) 상수
메모리 공간에 이름이 있는 변수와 달리 메모리 공간에 이름이 없는 상수를 리터럴 상수 또는 리터럴이라 한다.

### 접미사를 이용한 다양한 상수의 표현
```c
int main(void)
{
    float num1 = 5.789;     // 경고 메세지 발생
    float num2 = 3.24 + 5.12;   // 경고 메세지 발생
    return 0;
}
```
- 초기화할 때, double형 데이터를 float형 변수에 저장하였으니, 데이터가 잘려나갈 수도 있습니다.
    - 5.789 -> 8바이트 크기의 double형 상수, float -> 4바이트 크기의 변수
    - ```float num1 = 5.789f;``` -> float형을 뜻하는 f 또는 F를 상수뒤에 붙여주면 된다.

**정수형 상수의 표현을 위한 접미사**  
| 접미사 | 자료형                | 사용의 예                         |
| :--- | :------------------- | :----------------------------- |
| U    | unsigned int         | unsigned int n = 1025U         |
| L    | long                 | long n = 2467L                 |
| UL   | unsigned long        | unsigned long n = 3456UL       |
| LL   | long long            | long long n = 5678LL           |
| ULL  | unsigned long long   | unsigned long long n = 8979ULL |

**실수형 상수의 표현을 위한 접미사**  
| 접미사 | 자료형                      | 사용의 예                             |
| :--- | :------------------------- | :---------------------------------- |
| F    | float                      | float f = 3.15F                     |
| L    | long double                | long double f = 5.789L              |


### 이름을 지니는 심볼릭 상수: const 상수
```c
int main(void)
{
    const int MAX = 100;        // MAX는 상수! 따라서 값의 변경 불가!
    const double PI = 3.1415;   // PI는 상수! 따라서 값의 변경 불가!
}
```
- const 키워드를 이용해서 상수를 만들 때 선언과 동시에 초기화를 시켜줘야 한다.
- 상수의 이름은 모두 대문자로 표시하고, 둘 이상의 단어로 연결할 때에는 MY_AGE와 같이 언더바를 이용해서 두 단어를 구분하는 것이 관례이다.

</br>

## 자료형의 반환
자료형의 변환이라는 것은 데이터의 표현방식을 바꾸는 것이다.
- 자동 형 변환(묵시적 형 변환)
- 강제 형 변환(명시적 형 변환)

### 대입연산의 전달과정에서 발생하는 자동 형 변환
대입 연산자의 왼편과 오른편에 존재하는 두 피연산자의 자료형이 일치하지 않으면, 왼편에 있는 피연산자를 대상으로 형 변환이 자동으로 일어난다.
- 실수형 데이터를 정수형 데이터로 변환하는 과정에서 '소수부의 손실'이 발생한다.
- 바이트 크기가 큰 정수를 바이트 크기가 작은 정수로 형 변환하는 경우 변환하고자 하는 정수의 바이트 크기에 맞춰서 상위 바이트를 단순에 소멸시킨다. 이로 인해 부호가 바뀔 수도 있으니, 주의가 필요하다.

### '정수의 승격(Intergral Promotion)'에 의한 자동 형 변환
int형의 연산 속도가 다른 자료형의 연산속도에 비해 동일하거나 더 빠르기 때문에 int보다 작은 크기의 정수형 데이터는 int형 데이터로 형 변환이 되어서 연산이 진행된다.

### 피연산자의 자료형 불일치로 발생하는 자동 형 변환
```double num1 = 5.15 + 19;```
- 피연산자의 자료형이 일치하지 않아서 발생하는 자동 형 변환은 데이터의 손실을 최소화하는 방향으로 진행된다.
- 형 변환의 우선순위는 정수 자료형보다 실수 자료형이 무조건 앞서는 형태로 정의되어 있다.

### 명시적 형 변환: 강제로 일으키는 형 변환
```c
#include <stdio.h>

int main(void)
{
    int num1 = 3, num2 = 4;
    double divResult;
    divResult = (double)num1 / num2;

    printf("나눗셈 결과 = %.1lf \n", divResult); // 0.8
    return 0;
}
```