# 파일 입출력

## 파일 개방과 입출력

### 파일 개방과 폐쇄
```c
// 파일을 열고 닫는 프로그램

#include <stdio.h>

int main(void)
{
    FILE *fp;                       // 파일 포인터

    fp = fopen("a.txt", "r");       // a.txt 파일을 읽기 전용으로 개방
    if (fp == NULL)                 // fp가 널 포인터라면 개방 실패
    {
        printf("파일이 열리지 않았습니다.\n");          // 파일이 열리지 않았습니다.
        return 1;
    }
    printf("파일이 열렸습니다.\n");
    fclose(fp);                     // 파일 닫기

    return 0;
}
```
- ```fopen```
    - 함수 원형: ```FILE *fopen(const char *, const char *);```
    - ```fopen``` 함수가 개방할 파일을 찾는 기본 위치는 [현재 작업 디렉터리]이다.
        - 현재 작업 디렉터리는 실행 파일이 있는 곳으로 프로그램이 실행되는 위치이다.
    - 개방 모드
        - r(read) : 읽기 위해 개방 or NULL 반환
        - w(write) : 파일의 내용을 지우고 쓰기 위해 개방 or 새로운 파일 생성
            - 같은 이름의 파일이 있으면 그 내용을 모두 지우고 개방하므로 주의해야 한다.
        - a(append) : 파일의 끝에 추가하기 위해 개방 or 새로운 파일 생성
    - 파일을 찾아 개방하면 파일 포인터를 반환한다.
        - 실제 파일이 있는 장치와 연결되는 스트림 파일을 메모리에 만든다. 그리고 해당 스트림 파일에 접근할 수 있도록 파일 포인터를 반환한다.
- ```fclose```
    - 함수 원형: ```int fclose(FILE *)```
    - 성공적으로 닫았을 때 0을 반환, 오류 발생시 EOF 반환
    - 스트림 파일에 남아있는 중요한 데이터가 장치에 기록되기 전에 시스템 사고로 지워질 수 있으므로 사용이 끝난 파일은 즉시 닫아 스트림 파일의 데이터를 장치에 기록하는 것이 좋다.


### 스트림 파일과 파일 포인터
스트림 파일은 프로그램과 입출력 장치 사이의 다리 역할을 하는 논리적인 파일이다.
- 프로그램은 일단 메모리에 있는 스트림 파일로 입출력을 수행하고 그 파일이 다시 키보드, 모니터, 하드디스크와 같은 물리적인 장치와 연결되어 실제적인 입출력을 수행한다.
- 스트림 파일은 문자 배열 형태의 버퍼를 가지고 있다.

**스트림 파일 사용의 장점**  
1. 스트림 파일을 사용하면 입출력 효율을 높이고 장치로부터 독립된 프로그래밍이 가능하다.
- 입출력 함수가 장치를 직접 접근하면 입출력 장치가 바뀔 때마다 함수를 수정해야 한다.

2. 스트림 파일을 사용하면 프로그램과 장치의 입출력 속도 차이를 줄일 수 있다.
- 스트림 파일의 버퍼에 출력 데이터를 모아 한꺼번에 장치로 보내면 장치가 데이터를 기록하는 시간에 프로그램이 다시 버퍼를 채울 수 있다.


### 문자 입력 함수 fgetc
- ```fgetc``` 함수는 파일에서 하나의 문자를 입력하여 반환한다.
    - 파일의 데이터를 모두 읽으면 EOF를 반환한다.
- 파일 포인터와 연결된 스트림 파일의 버퍼에서 데이터를 가져온다.
    - 처음에는 버퍼가 비어 있으므로 하드디스크에서 데이터를 가져와 버퍼를 채운다.
    - 하드디스크에서 데이터를 가져올 때는 한 번에 버퍼의 크기만큼 가져와 저장한다.
    - ```fgetc``` 함수가 두 번재 호출될 때는 이미 버퍼에 저장된 데이터가 있으므로 버퍼로부터 바로 문자를 읽어 들인다.
- 스트림 파일에는 문자를 입력할 버퍼의 위치를 알려주는 지시자가 있다.
    - 위치 지시자는 파일이 개방되면 0으로 초기화되며 입력 함수가 데이터를 읽을 때 그 크기만큼 증가한다.
```c
// 파일의 내용을 화면에 출력하기

#include <stdio.h>

int main(void)
{
    FILE *fp;                   // 파일 포인터 선언
    int ch;                     // 입력할 문자를 저장할 변수

    fp = fopen("../data/a.txt", "r");
    if (fp == NULL)
    {
        printf("파일이 열리지 않았습니다.\n");
        return 1;
    }

    while (1)
    {
        ch = fgetc(fp);         // 개방한 파일에서 문자 입력
        if (ch == EOF) { break; }
        putchar(ch);            // 입력한 문자를 화면에 출력
    }
    fclose(fp);

    return 0;
}
```


### 문자 출력 함수 fputc
한 문자를 파일로 출력할 때는 ```fputc``` 함수를 사용한다.
- 출력할 문자와 파일 포인터를 인수로 주면 파일로 문자를 출력한다.
- 출력 과정에서 스트림 파일의 버퍼를 사용하며, 버퍼에 데이터를 모은 후에 한 번에 출력한다.
- 버퍼의 데이터를 하드디스크에 기록하기 전에 갑자기 전원이 꺼지면 데이터가 지워질 수 있으므로 주의해야 한다.
- 버퍼의 데이터를 즉시 장치로 출력해야 한다면 ```fflush``` 함수를 사용해야한다.
```c
// 문자열을 한 문자씩 파일로 출력하기

#include <stdio.h>

int main(void)
{
    FILE *fp;
    char str[] = "banana";
    int i;

    fp = fopen("../data/b.txt", "w");
    if (fp == NULL)
    {
        printf("파일을 만들지 못했습니다.\n");
        return 1;
    }

    i = 0;
    while (str[i] != '\0')
    {
        fputc(str[i], fp);
        i++;
    }
    fputc('\n', fp);
    fclose(fp);

    return 0;
}
```


### 기본적으로 개방되는 표준 입출력 스트림 파일
운영체제는 프로그램을 실행할 때 기본적으로 3개의 스트림 파일을 만든다.
- 이들을 키보드와 모니터 등에 연결하여 입출력 함수들이 파일 포인터 없이 사용할 수 있도록 제공한다.
- stdin : 표준 입력 스트림 -> 키보드
    - ```getchar``` 함수는 내부적으로 stdin을 사용하므로 표준 입력 스트림 버퍼를 통해 입력한다.
        - 처음 호출되면 키보드에서 입력하는 데이터는 개행 문자와 함께 stdin 스트림 파일의 버퍼에 한꺼번에 저장된다.
        - 이후 버퍼에서 첫 번째 문자를 가져다 반환하고 차례로 다음 문자를 반환한다.
        - 반복문 안에서 여러 번 호출되지만 문자열은 키보드 한 번에 입력한다.
        - Ctrl + Z => EOF를 반환하여 프로그램이 종료된다.
- stdout : 표준 출력 스트림 -> 모니터
- stderr : 표준 에러 스트림 -> 모니터
- ```fgetc```, ```fputc``` 함수에 stdin, stdout을 인수로 주면 별도의 파일을 개방하지 않고 운영체제가 개방한 스트림 파일을 사용할 수 있다.


### 텍스트 파일과 바이너리 파일
- 텍스트 파일은 데이터를 아스키 코드 값에 따라 저장한 것이며, 그 이외의 방식으로 저장된 파일은 바이너리 파일이다.
- 개방 모드에 텍스트 파일은 t, 바이너리 파일은 b를 추가하여 개방한다.
    - rb : 바이너리 파일을 읽기 위해 개방
    - wb : 바이너리 파일을 쓰기 위해 개방
    - ab : 바이너리 파일의 끝에 추가하기 위해 개방
- 파일의 형태를 별도로 표시하지 않으면 자동으로 텍스트 파일로 개방한다.
```c
// 파일의 형태와 개방 모드가 다른 경우

#include <stdio.h>

int main(void)
{
    FILE *fp;
    int ary[10] = { 13, 10, 13, 13, 10, 23, 23, 33, 31, 12};
    int i, res;

    fp = fopen("../data/c.txt", "wb");      // 바이너리 파일로 개방
    for (i = 0; i < 10; i++) { fputc(ary[i], fp);}
    fclose(fp);

    fp = fopen("../data/c.txt", "rt");      // 같은 파일을 텍스트 파일로 개방
    while (1)
    {
        res = fgetc(fp);
        if (res == EOF) { break; }
        printf("%4d", res);
    }
    fclose(fp);

    return 0;
}
```
- ```fgetc``` 함수는 리턴 문자(\r)를 읽으면 버리고 다음의 개행 문자(\n) 하나만 입력한다.
- ```fgetc``` 함수는 Ctrl + Z 에 대한 아스키 문자를 읽으면 파일의 끝으로 인식한다.
- 텍스트 파일에 출력하는 함수는 개행 문자를 출력할 때 리턴 문자를 추가하여 2개의 문자를 파일에 출력한다.
    - 바이너리 모드로 개방된 파일은 파일의 내용을 있는 그대로 읽거나 쓴다.
- 운영체제에 따라 줄을 바꾸는 방식이 다를 수 있다.
    - 유닉스 시스템에서는 줄 바꿈을 위해 개행 문자(\n)만 사용한다.
    - macOS 시스템은 리턴 문자(\r)를 사용한다.
    - 유닉스 시스템은 파일의 형태를 텍스트 파일과 바이너리 파일로 구분하지 않으며 모두 바이너리 파일로 취급한다.


### + 개방 모드, fseek, rewind, feof 함수
`+` 를 사용하면 읽고 쓰는 작업을 함께 할 수 있다.
- r+ : 텍스트 파일에 읽고 쓰기 위해 개방
- w+ : 텍스트 파일의 내용을 지우고 읽거나 쓰기 위해 개방
- a+ : 텍스트 파일을 읽거나 파일의 끝에 추가하기 위해 개방
- rb+ : 바이너리 파일을 읽고 스기 위해 개방
- wb+ : 바이너리 파일의 내용을 지우고 읽거나 쓰기 위해 개방
- ab+ : 바이너리 파일을 읽거나 파일의 끝에 추가하기 위해 개방
```c
// a+ 모드로 파일의 내옹을 확인하며 출력

#include <stdio.h>
#include <string.h>

int main(void)
{
    FILE *fp;
    char str[20];

    fp = fopen("../data/a.txt", "a+");
    if (fp == NULL)
    {
        printf("파일을 만들지 못했습니다.\n");
        return 1;
    }

    while (1)
    {
        printf("과일 이름 : ");
        scanf("%s", str);
        if (strcmp(str, "end") == 0) { break; }
        else if (strcmp(str, "list") == 0)  // list를 입력하면 파일의 내용 확인
        {
            fseek(fp, 0, SEEK_SET);         // 버퍼의 위치 지시자를 맨 처음으로 이동
            while (1)
            {
                fgets(str, sizeof(str), fp);    // 과일 이름을 읽는다.
                if (feof(fp))                   // 파일의 내용을 모두 읽으면 종료
                {
                    break;
                }
                printf("%s", str);              // 읽은 과일 이름을 화면 출력
            }
        }
        else { fprintf(fp, "%s\n", str);}       // 입력한 과일 이름을 파일에 출력
    }
    fclose(fp);

    return 0;
}
```
- ```fseek``` 함수 : 파일의 입력과 출력을 서로 전환할 때마다 호출해야 한다.
    - 함수 원형 : ```int fseek(FILE * stream, long offset, int whence)```
        - 첫 번째 인수인 stream 파일의 버퍼에서 whence를 기준으로 offset만큼 위치 지시자를 옮긴다.
        - 위치 이동에 실패하면 0, 성공하면 0이 아닌 값을 반환.
        - whence
            - 0, SEEK_SET, 파일의 처음, 양수만 가능
            - 1, SEEK_CUR, 파일의 현재 위치, 양수와 음수 모두 가능
            - 2, SEEK_END, 파일의 끝, 음수만 가능
    - (ex) ```fseek(fp, 0, SEEK_SET);``` = ```rewind(fp)```
        - 스트림 파일 위치 지시자를 시작 위치로 옮기며 그 전에 버퍼의 내용을 하드디스크로 출력한다.
    - (ex) ```fseek(fp, -5, SEEK_END);```
        - 파일의 끝에서 다섯 문자 앞쪽으로 위치 지시자를 옮긴다.
    - ```fprintf``` 함수는 스트림 파일의 버퍼에 데이터를 출력해놓는데, 버퍼에 데이터가 있는 상태에서 바로 하드디스크로부터 데이터를 입력하게 되면 입출력 순서가 꼬인다.
    - 버퍼의 데이터를 하드디스크로 옮기고 버퍼를 읽기 위한 공간으로 설정한 후에 하드디스크의 데이터를 처음부터 다시 읽도록 해야 한다.
- 어떤 경우든 a+ 모드에서 출력하는 데이터는 상항 파일의 맨 뒤에 붙여넣기가 된다.
- w+ 모드는 데이터를 읽다가 중간에 다시 쓰는 경우 ```fseek``` 함수로 설정한 위치부터 내용을 덮어쓴다.
- r+ 모드는 읽기를 먼저 하든 쓰기를 먼저 하든 상관없지만 읽기와 쓰기를 서로 바꿀 때는 ```fseek``` 함수로 파일에서 읽고 쓸 위치를 알려줘야 한다.
    - 파일을 열자마자 데이터를 출력하면 파일의 내용을 앞에서부터 덮어쓰며, 파일의 끝까지 다 읽은 후에 출력하면 ```fseek``` 함수 호출 없이 바로 이어서 출력할 수 있다.
- ```feof``` 함수는 스트림 파일의 데이터를 모두 읽었는지 확인할 때 유용하다.
    - 파일의 끝이면 0이 아닌 값을 반환하고 끝이 아니면 0을 반환한다.

</br>

## 다양한 파일 입출력 함수

### fgets와 fputs : 한 줄씩 입출력
- ```fgets``` : 파일에서 데이터를 한 줄씩 입력할 때 사용
    - 읽을 데이터의 크기가 큰 경우 저장 공간의 크기까지만 입력할 수 있으므로 메모리 침범의 가능성을 차단한다.
- ```fputs``` : 문자열을 파일에 출력할 때 사용
```c
// 여러 줄의 문장을 입력하여 한 줄로 출력

#include <stdio.h>
#include <string.h>

int main(void)
{
    FILE *ifp, *ofp;
    char str[80];                   // 입력한 문자열을 저장할 배열
    char *res;                      // fgets 함수의 반환값을 저장할 변수

    ifp = fopen("../data/a.txt", "r");
    if (ifp == NULL)
    {
        printf("입력 파일을 열지 못했습니다.\n");
        return 1;
    }

    ofp = fopen("../data/b.txt", "w");
    if (ofp == NULL)
    {
        printf("입력 파일을 열지 못했습니다.\n");
        return 1;
    }

    while (1)
    {
        res = fgets(str, sizeof(str), ifp);
        if (res == NULL) { break; }
        str[strlen(str) - 1] = '\0';        // 개행 문자 제거
        fputs(str, ofp);
        fputs(" ", ofp);
    }

    fclose(ifp);
    fclose(ofp);

    return 0;
}
```
- ```fgets(str: 입력할 배열, sizeof(str): 배열의 크기, ifp: 파일 포인터)```
    - 개방한 파일에서 공백을 포함하여 한 줄씩 읽어 배열에 저장한다.
    - 줄의 끝에 있는 개행 문자(\n)까지 입력한다.
        - 처음 호출될 때 첫 줄의 개행 문자까지 읽어들여 str 배열에 저장된다.
    - ```str[strlen(str) - 1] = '\0';```
        - 개행 문자를 제거하는 경우 입력 파일의 형식에 주의해야한다.
            - a.txt 파일을 만들 때 banana를 입력하고 Enter를 누르지 않으면 ```fgets``` 함수는 banana만 배열에 저장하므로 개행 문자를 제거하는 코드가 수행되어 마지막 문자인 a가 지워진다.
    - 입력을 마치면 입력한 배열의 주소를 다시 반환한다. 이를 활용하면 함수를 호출한 후에 바로 입력된 데이터를 사용할 수 있어 편리하다.
        - 더 이상 읽을 데이터가 없으면 NULL을 반환하므로, 반복적으로 ```fgets``` 함수를 호출할 때 파일의 끝을 검사하기 위해서 반환값을 NULL과 비교해야 한다. (EOF(-1)을 사용하지 않도록 주의하자!)
    - stdin을 파일 포인터로 주면 키보드로 입력이 가능하다.
- ```fputs(출력할 문자열, 파일 포인터)```
    - 문자열을 파일에 출력하며 성공하면 시스템에 따라 0 또는 출력한 문자의 수를 반환하고 실패하면 EOF를 반환한다.
    - stdout을 파일 포인터로 주면 모니터로 출력이 가능하다.

**fgets, fputs를 사용해야 하는 이유**  
- ```gets``` 함수는 입력할 저장 공간의 크기를 인수로 줄 수 없으므로 문자열을 입력할 때 할당하지 않은 메모리 공간을 침범할 가능성이 있다.
- ```puts``` 함수는 항상 줄을 바꾸므로 문자열을 이어서 출력할 수 없다.


### fscanf, fprintf : 다양한 형태의 입출력
- ```fscanf``` : 파일에 저장된 문자열을 숫자로 변환하여 입력할 때 사용
    - 파일의 데이터를 입력할 각 변수의 형태에 맞게 자동 변환된다.
    - 파일의 데이터를 모두 읽으면 EOF를 반환한다.
- ```fprintf``` : 정수나 실수를 쉽게 파일에 출력할 때 사용
    - 각 변수의 데이터를 모두 문자열로 변환하여 파일에 출력한다.
    - 출력한 문자의 바이트 수를 반환하며 출력 과정에서 오류가 발생하면 음수를 반환한다.
```c
// 다양한 자료형을 형식에 맞게 입출력

#include <stdio.h>

int main(void)
{
    FILE *ifp, *ofp;
    char name[20];
    int kor, eng, math;
    int total;
    double avg;
    int res;

    ifp = fopen("../data/d.txt", "r");
    if (ifp == NULL)
    {
        printf("입력 파일을 열지 못했습니다.\n");
        return 1;
    }

    ofp = fopen("../data/e.txt", "w");
    if (ofp == NULL)
    {
        printf("출력 파일을 열지 못했습니다.\n");
        return 1;
    }

    while (1)
    {
        res = fscanf(ifp, "%s%d%d%d", name, &kor, &eng, &math);
        if (res == EOF) { break; }
        total = kor + eng + math;
        avg = total / 3.0;
        fprintf(ofp, "%s%5d%7.1lf\n", name, total, avg);
    }

    fclose(ifp);
    fclose(ofp);

    return 0;
}
```


### 스트림 파일의 버퍼 공유 문제와 fflush 함수
스트림 파일을 사용하는 입출력 함수들이 버퍼를 공유하면 예상과 다른 결과가 나올 수 있다.
```c
// 버퍼를 공유함으로 인해 발생하는 문제

#include <stdio.h>

int main(void)
{
    FILE *fp;
    int age;
    char name[20];

    fp = fopen("../data/f.txt", "r");

    fscanf(fp, "%d", &age);
    fgets(name, sizeof(name), fp);

    printf("나이 : %d, 이름 : %s", age, name); // 나이 : 17, 이름 : 
    fclose(fp);

    return 0;
}
```
- ```fscanf``` 함수가 나이를 입력한 후에 버퍼에 남겨놓은 개행 문자를 다음에 호출되는 ```fgets``` 함수가 이어서 입력해버린다.
    - ```fgets``` 함수는 개행 문자가 나올 때까지 문자열을 이력하는데 처음부터 개행 문자가 있으므로 개행 문자만 입력한다.
- ```fgets(name, sizeof(name), fp);``` -> ```fscanf(fp, "%s", name);```
    - ```fscanf``` 함수가 공백을 입력 데이터를 구분하는 용도로 사용하므로 "Hong"만 입력하는 문제가 발생한다.
- ```fgetc``` 함수를 사이에 넣어 스트림 버퍼에서 개행 문자를 읽어내는 방법으로 해결한다.
- ```fflush``` : 스트림 파일의 버퍼를 비우는 함수
    - 함수 원형 : ```int fflush(FILE *) // 인수는 스트림 파일의 포인터```
    - 파일 포인터를 인수로 주면 파일 포인터와 연결된 스트림 파일의 버퍼를 비운다.
    - 반환값은 0이며 버퍼를 비우지 못했을 때는 EOF를 반환한다.
    - 입력 파일에 대해서는 표준이 정의되어 있지 않고 사용하면 시스템에 따라 변화가 없거나 컴파일 에러가 나기도 한다.
    - 출력 파일에 사용하면 버퍼를 비우면서 남은 데이터를 연결된 장치로 바로 출력한다.
    - 출력 함수를 호출한 후에 버퍼의 데이터를 즉시 하드디스크와 같은 장치로 저장해야한다면 ```fflush``` 함수를 사용할 수 있다.


### fread와 fwrite 함수
두 함수는 입출력할 데이터의 크기와 개수를 인수로 줄 수 있으므로 구조체나 배열과 같이 데이텨양이 많은 경우도 파일에 쉽게 입출력할 수 있다.
- 숫자와 문자 사이의 변환 과정을 수행하지 않으므로 입출력 효율을 높일 수 있다.
- 파일의 내용을 메모장 같은 편집기로 직접 확인할 수 없다.
```c
// fprintf와 fwrite 함수의 차이

#include <stdio.h>

int main(void)
{
    FILE *afp, *bfp;
    int num = 10;
    int res;

    afp = fopen("../data/g.txt", "wt");
    fprintf(afp, "%d", "num");

    bfp = fopen("../data/h.txt", "wb");
    fwrite(&num, sizeof(num), 1, bfp);

    fclose(afp);
    fclose(bfp);

    bfp = fopen("../data/h.txt", "rb");
    fread(&res, sizeof(res), 1, bfp);
    printf("%d", res);

    fclose(bfp);

    return 0;
}
```
- ```fwrite(&num: 출력할 데이터의 주소, sizeof(num): 크기, 1: 개수, bfp: 파일 포인터);```
    - 주어진 메모리 위치로 가서 크기와 개수를 곱한 바이트 수를 읽어 파일 포인터의 파일에 출력한다.
    - 아스키 코드로의 변환과정 없이 메모리에 있는 데이터를 그대로 파일에 저장한다. 따라서, 텍스트 파일 편집기로 보거나 편집할 수 없다.
- ```fread```, ```fwrite``` 함수가 데이터를 있는 그대로 입출력할 수 있도록 파일은 항상 바이너리 모드로 개방한다.