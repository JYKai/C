# 배열과 포인터

## 배열과 포인터의 관계
배열의 첫 번째 요소의 주소를 알면 나머지 요소의 주소도 쉽게 알 수 있으므로, 각 주소에 간접 참조 연산을 수행하면 모든 배열 요소를 사용할 수 있다. 따라서, 컴파일러는 첫 번째 배열 요소의 주소를 쉽게 사용할 수 있도록 **배열명을 컴파일 과정에서 첫 번째 요소의 주소**로 변경한다.

### 배열명으로 배열 요소 사용하기
주소는 정수처럼 보이지만 자료형에 대한 정보를 갖고 있는 특별한 값이다. 따라서 연산을 자유롭게 할 수 없고 정해진 연산만 가능하다.
```주소 + 정수 -> 주소 + (정수 * 주소를 구한 변수의 크기)``` = int형 변수(4바이트) ```100 + 1 = 100 + (1 * 4)```  

```c
// 배열명에 정수 연산을 수행하여 배열 요소 사용

#include <stdio.h>

int main(void)
{
    int ary[3];
    int i;

    *(ary + 0) = 10;                    // ary[0] = 10
    *(ary + 1) = *(ary + 0) + 10;       // ary[1] = ary[0] + 10;

    printf("세 번째 배열 요소에 키보드 입력 : ");
    scanf("%d", ary + 2);               // &ary[2];

    for (i = 0; i < 3; i++)
    {
        printf("%5d", *(ary + i));      // ary[i]
    }

    return 0;
}
```
- 배열의 대괄호([])는 포인터 연산의 '간접 참조, 괄호, 더하기' 연산 기능을 갖는다. ```ary[1] = *(ary + 1)```
- 배열의 할당 영역을 벗어나는 포인터 연산직은 사용할 수 있으나 사용하면 안된다. 문법적으로 문제가 없으므로 컴파일은 되나 실행할 때 결과를 예상할 수 없다.


### 배열명 역할을 하는 포인터
배열명은 주소이므로 포인터에 저장할 수 있다.
- 포인터로도 연산식이나 대괄호를 사용해서 배열 요소를 쉽게 사용할 수 있다.
```c
// 배열명처럼 사용되는 포인터

#include <stdio.h>

int main(void)
{
    int ary[3];                 // 배열 선언
    int *pa = ary;              // 포인터에 배열명 저장
    int i;

    *pa = 10;                   // 첫 번째 배열 요소에 10 대입
    *(pa + 1) = 20;             // 두 번째 배열 요소에 20 대입
    pa[2] = pa[0] + pa[1];      // 대괄호를 사용해서 pa를 배열명처럼 사용

    for (i = 0; i < 3; i++)
    {
        printf("%5d", pa[i]);   // 포인터로 모든 배열 요소 출력
    }

    return 0;
}
```


### 배열명과 포인터의 차이
1. sizeof 연산의 결과가 다르다.
- 배열명에 사용할 경우 배열 전체의 크기를 구하고, 포인터에 사용하면 포인터 하나의 크기를 구한다.
    - 배열명을 포인터에 저장하면 포인터로 배열 전체의 크기를 확인하는 것은 불가능하다.
2. 변수와 상수의 차이가 있다.
- 포인터는 그 값을 바꿀 수 있지만, 배열명은 상수이므로 값을 바꿀 수 없다.
```c
// 포인터를 이용한 배열의 값 출력

#include <stdio.h>

int main(void)
{
    int ary[3] = { 10, 20, 30 };
    int *pa = ary;
    int i;

    printf("배열의 값 : ");
    for (i = 0; i < 3; i++)
    {
        printf("%d ", *pa);     // pa가 가리키는 배열 요소 출력
        pa++;                   // 다음 배열 요소를 가리키도록 pa 값 증가
    }

    return 0;
}
```
- 포인터의 값이 변할 수 있으므로 유효한 값인지 확인하는 습관이 필요하다.
    - 위의 경우 반복문을 모두 수행한 후 포인터의 위치는 할당된 배열의 주소를 벗어난다.
- 포인터에 증가 연산자와 간접 참조 연산자를 함께 사용할 때 전위 표현을 사용하면 안된다.
    - 마지막에 출력되는 값은 배열의 값이 아닌 쓰레기 값이 출력된다.


### 포인터의 뺄셈과 관계 연산
가리키는 자료형이 같으면 포인터끼리의 뺄셈이 가능하다. ``` 포인터 - 포인터 -> 값의 차 / 가리키는 자료형의 크기 ```  
관계 연산자로 대소관계도 확인할 수 있다.
```c
// 포인터의 뺄셈과 관계 연산

#include <stdio.h>

int main(void)
{
    int ary[5] = { 10, 20, 30, 40, 50 };
    int *pa = ary;
    int *pb = pa + 3;

    printf("pa : %u\n", pa);
    printf("pb : %u\n", pb);

    pa++;
    printf("pb - pa : %u\n", pb - pa);

    printf("앞에 있는 배열 요소의 값 출력: ");
    if (pa < pb) { printf("%d\n", *pa); }
    else { printf("%d\n", pb); }

    return 0;
}
```
- 뺄셈 결과는 배열 요소 간의 간격 차이를 의미한다.
- 배열은 배열 요소가 메모리에 순서대로 할당되므로 앞의 배열 요소가 뒤의 배열 요소보다 주소 값이 작으므로, 관계 연산의 결과로 두 포인터가 가리키는 배열 요소의 순서를 확인할 수 있다.

</br>

## 배열을 처리하는 함수
함수로 배열을 처리하려면 포인터가 필요하다. 즉, 배열명을 받을 함수의 매개변수 자리에 포인터가 필요하다.
- 배열의 모든 요소가 int형이면 첫 번째 요소 또한 int형이다. 배열명을 함수의 인수로 준다는 것은 결국 int형 변수의 주소를 전달하는 것이므로 매개변수로 받을 때는 int형 변수의 주소를 저장할 포인터를 선언해야 한다. = ```void print_ary(int *pa)```  

### 배열의 값을 출력하는 함수
첫 번째 배열 요소의 주소만 알면 나머지 배열 요소는 포인터 연산으로 모두 사용할 수 있다.
- 함수를 호출할 때는 배열명만 주고 함수의 매개변수로 포인터를 선언한다. 함수 안에서 포인터를 배열명처럼 사용하면 된다.
```c
// 배열을 처리하는 함수

#include <stdio.h>

void print_ary(int *pa, int count);

int main(void)
{
    int ary[5] = { 10, 20, 30, 40, 50 };
    int count = sizeof(ary) / sizeof(ary[0]);
    print_ary(ary, count);

    return 0;
}

void print_ary(int *pa, int count)
{
    int i;

    for (i = 0; i < count; i++)
    {
        printf("%d ", pa[i]);
    }
}
```
- 위와 같은 처리 방식은 배열에 있는 대량의 데이터를 다른 함수로 복사하지 않고 접근하므로 더 효율적이다.
    - 다만 주소만 알면 해당 위치의 값을 바꿀 수도 있으므로 의도치 않게 값을 변형하는 일이 없도록 주의해야 한다.
- sizeof 연산자를 배열명에 사용하면 배열 전체 크기를 구하지만 포인터에 사용하면 포인터 자체의 크기만을 계산하기 때문에, print_ary 함수 안에서 배열의 크기를 알 수 없다.


### 배열에 값을 입력하는 함수
```c
// 배열에 값을 입력하는 함수

#include <stdio.h>

void input_ary(double *pa, int size);
int find_max(double *pa, int size);

int main(void)
{
    double ary[5];
    double max;
    int size = sizeof(ary) / sizeof(ary[0]);

    input_ary(ary, size);
    max = find_max(ary, size);
    printf("배열의 최댓값 : %.1lf\n", max);

    return 0;
}

void input_ary(double *pa, int size)
{
    int i;

    printf("%d개의 실수값 입력 : ", size);
    for (i = 0; i < size; i++) { scanf("%lf", pa + i); }
}

int find_max(double *pa, int size)
{
    double max;
    int i;

    max = pa[0];
    for (i = 1; i < size; i++)
    {
        if (pa[i] > max) { max = pa[i]; }
    }

    return max;
}
```

**함수의 매개변수 자리에 배열을 선언하는 경우**  
함수의 매개변수 자리에 배열을 선언하면 배열의 저장 공간이 할당되지 않으며, 배열명은 컴파일 과정에서 첫 번째 배열 요소를 가리키는 포인터로 바뀐다.
- 매개변수 자리에 선언된 배열에서 배열 요소의 개수는 의미가 없으며 생략도 가능하다.
- 컴파일러는 배열명을 자동으로 포인터로 바꾸고 모든 배열 요소를 사용할 수 있도록 포인터 연산을 수행한다.