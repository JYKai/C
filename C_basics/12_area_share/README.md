# 변수의 영역과 데이터 공유

## 변수 사용 영역
변수는 사용 범위와 메모리에 존재하는 기간에 따라 종류가 다양하다.

### 지역 변수(local variable)
지역 변수는 범위가 함수 내, 즉 일정 지역에서만 사용하는 변수이다.
- 지역 변수와 자동 변수는 같은 용어이다.
- 지역 변수는 기억 분류 중 하나이다.
    - 기억 분류는 변수를 사용 범위와 메모리에서의 존재 기간에 따라 나눈 것이다.
- 지역 변수는 변수의 특성 중에 사용 범위를 강조한 것이며, 자동 변수는 지역 변수가 auto 예약어를 사용하므로 쓰는 용어이다.
- 지역 변수는 사용 범위가 블록 내부로 제한되므로 다른 함수에서는 사용할 수 없다.
- 지역 변수는 이름이 같아도 선언된 함수가 다르면 각각 독립된 저장 공간을 갖는다.
- 함수의 매개변수는 지역 변수이다.

**장점**  
- 메모리를 효율적으로 사용할 수 있다.
    - 함수 안에서만 사용하므로 함수가 반환되면 그 저장 공간을 계속 유지할 필요가 없다.
- 디버깅에 유리하다.
    - 지역 변수가 할당된 저장 공간은 자동으로 초기화되지 않으므로 쓰레기 값이 사용되지 않도록 주의해야 한다.


### 블록 안에서 사용하는 지역 변수
- 특정 블록 안에 변수를 선언하면 사용 범위가 블록 내부로 제한된다.
```c
// 블록 안에서 지역 변수를 사용하여 두 변수를 교환하는 프로그램

#include <stdio.h>

int main(void)
{
    int a = 10, b = 20;

    printf("교환 전 a와 b의 값 : %d, %d\n", a, b);  // 교환 전 a와 b의 값 : 10, 20
    {
        int temp;   // 변수 temp는 사용 범위가 블록 내부로 제한된다.

        temp = a;
        a = b;
        b = temp;
    }
    printf("교환 후 a와 b의 값 : %d, %d\n", a, b);  // 교환 후 a와 b의 값 : 20, 10

    return 0;
}
```
- 사용 가능한 변수가 둘 이상이면 가장 가까운 블록에 선언된 변수를 사용한다.
- 특정 블록 안에 변수를 선언하면 필요한 경우 잠깐 사용하고 메모리를 재활용하는 효과를 볼 수 있다.
    - ```int temp;```
    - 하지만, 중첩된 블록에서 같은 이름의 변수를 선언하면 예상치 못한 결과를 얻을 수 있으므로 지양해야 한다.


### 전역 변수(global variable)
전역 변수는 특정 함수의 블록에 포함되지 않으므로 사용 범위가 함수나 블록으로 제한되지 않는다.
- 전역 변수의 사용 범위는 프로그램 전체이므로 어떤 함수라도 안에서 직접 사용할 수 있다.
- 함수 밖에 변수를 선언하면 전역 변수가 되며 특별한 예약어는 사용하지 않는다.
- 전역 변수는 특정 함수 안에 있는 것이 아니므로 저장 공간이 메모리에 존재하는 기간이 지역 변수보다 훨씬 길다.
- 전역 변수는 특별한 값으로 초기화하지 않아도 0으로 자동 초기화된다.
- 전역 변수와 지역 변수의 이름이 같으면 지역 변수를 먼저 사용한다.

**문제점**  
- 전역 변수의 이름을 바꾸면 그 변수를 사용하는 모든 함수를 찾아 수정해야한다.
- 전역 변수의 값이 잘못된 경우 접근 가능한 모든 함수를 의심해야 한다.
- 코드 블록 내에 같은 이름의 지역 변수를 선언하면 그 영역에서는 전역 변수를 사용할 수 없다.

결국 사용 범위가 명확하고 통제 가능한 지역 변수를 우선적으로 사용하며 전역 변수는 제한적으로 사용하는 것이 좋다.


### 정적 지역 변수(static variable)
지역 변수를 선언할 때 static 예약어를 사용하면 정적 지역 변수가 된다. 정적 지역 변수는 코드 블록 안에 선언하므로 일반 지역 변수와 같이 사용 범위가 블록 내부로 제한되지만, 저장 공간이 메모리에 존재하는 기간이 다르다.
- 선언된 함수가 반환되더라도 그 저장 공간을 계속 유지한다.
- 하나의 함수가 여러 번 호출되는 경우 같은 변수를 공유하는 것이 가능하다.
    - 정적 지역 변수의 저장 공간은 프로그램이 실행되는동안 계속 유지된다.
- 정적 지역 변수를 초기화하지 않으면 0으로 자동 초기화된다.
```c
// auto 지역 변수와 static 지역 변수의 비교

#include <stdio.h>

void auto_func(void);
void static_func(void);

int main(void)
{
    int i;

    printf("일반 지역 변수(auto)를 사용한 함수...\n");
    for (i = 0; i < 3; i++)
    {
        auto_func();
    } // 1 1 1

    printf("정적 지역 변수(static)를 사용한 함수...\n");
    for (i = 0; i < 3; i++)
    {
        static_func();
    } // 1 2 3

    return 0;
}

void auto_func(void)
{
    auto int a = 0;

    a++;
    printf("%d\n", a);
}

void static_func(void)
{
    static int a = 0;

    a++;
    printf("%d\n", a);
}
```
- ```static int a = 0;```
    - static_func 함수 안에 선언되었지만, 저장 공간의 할당이나 초기화 방법, 메모리 존재 기간이 전역 변수와 같다.
    - 정적 지역 변수는 선언된 블록 안에서만 사용하는 전역 변수와 같다.


### 레지스터 변수(register variable)
레지스터 변수는 블록 혹은 함수 내에 변수를 선언할 때 register 예약어를 사용한다.
- CPU안에 있는 저장 공간인 레지스터를 사용한다.
- 반복문에 쓰는 변수와 같이 사용 횟수가 많은 경우 레지스터에 할당하면 실행 시간을 줄일 수 있다.
```c
// 레지스터 변수를 반복문에 사용한 예

#include <stdio.h>

int main(void)
{
    register int i;
    auto int sum = 0;

    for (i = 1; i <= 10000; i++) { sum +=i; }
    printf("%d\n", sum);

    return 0;
}
```
- 자주 사용하는 변수를 레지스터 변수로 선언하면 변수의 저장 공간이 램 메모리에 있을 때보다 빨라 프로그램 실행 시간을 줄일 수 있다.

**레지스터 변수 사용 시 주의사항**  
1. 전역 변수는 레지스터 변수로 사용할 수 없다.
- 레지스터 변수는 CPU의 자원을 잠깐 빌리는 것이므로 프로그램을 실행하는 동안 계속 저장 공간을 확보해야 하는 전역 변수는 레지스터에 할당할 수 없다.

2. 레지스터 변수는 주소를 구할 수 없다.

3. 레지스터의 사용 여부는 컴파일러가 결정한다.
- 컴파일러는 사용자가 레지스터 변수를 선언하더라도 레지스터와 메모리 중에 어디에 할당하는 것이 더 이득인지 판단하여 적당한 저장 공간을 선택한다.

</br>

## 함수의 데이터 공유 방법

### 값을 복사해서 전달하는 방법
가장 일반적인 방법이며, 함수를 호출할 때 변수뿐만 아니라 상수나 수식도 사용할 수 있다.
- 호출된 함수가 반환된 이후에도 호출한 함수에 있는 변수의 값은 변하지 않는다.
- 원본 데이터를 보존할 수 있으므로 안정성을 담보 해야 하는 상황에 유용하다.

### 주소를 전달하는 방법
포인터 연산으로 값을 처리해야 한다.
- 호출된 함수에서 호출한 함수에 있는 변수의 값을 바꿀 수 있다.
- 원본 데이터를 바꿀 때 유용하지만, 바꾸면 안되는 데이터를 다룰 때 사용하면 문제가 될 수 있다.
    - 꼭 필요한 경우가 아니라면 값을 복사해서 전달하는 방식을 기본으로 사용한다.


### 주소를 반환하는 함수
함수가 반환된 후에도 변수의 저장 공간이 계속 유지된다면 주소를 반환하여 호출하는 함수에서 쓸 수도 있다.
- 정적 지역 변수, 전역 변수는 주소를 반환할 수 있다.
```c
// 주소를 반환하여 두 정수의 합 계산

#include <stdio.h>

int *sum(int a, int b);

int main(void)
{
    int *resp;

    resp = sum(10, 20);
    printf("두 정수의 합 : %d\n", *resp);

    return 0;
}

int *sum(int a, int b)
{
    static int res;

    res = a + b;

    return &res;
}
```
- 반환값의 자료형은 반환값을 저장할 포인터의 자료형과 같아야 한다.
- 지역 변수의 주소를 반환해서는 안된다.
    - 일반 지역 변수는 함수가 반환되면 저장 공간이 회수되어 언제 다른 용도로 재활용될지 알 수 없다.

